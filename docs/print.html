<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Juniper - Rust 语言的 GraphQL 服务器</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content=" Juniper 中文手册，一个用于 Rust 语言的 GraphQL 服务器库。">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        <script>
            var _hmt = _hmt || [];
            (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?914b11ce474468058b0d2816ef521c9e";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
            })();
        </script>
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="contributing.html">做贡献</a></li><li class="spacer"></li><li><a href="index.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><a href="quickstart.html"><strong aria-hidden="true">2.</strong> 快速入门</a></li><li><a href="types/index.html"><strong aria-hidden="true">3.</strong> 类型系统</a></li><li><ol class="section"><li><a href="types/objects/defining_objects.html"><strong aria-hidden="true">3.1.</strong> 定义对象</a></li><li><ol class="section"><li><a href="types/objects/complex_fields.html"><strong aria-hidden="true">3.1.1.</strong> 复杂字段</a></li><li><a href="types/objects/using_contexts.html"><strong aria-hidden="true">3.1.2.</strong> 上下文</a></li><li><a href="types/objects/error_handling.html"><strong aria-hidden="true">3.1.3.</strong> 错误处理</a></li></ol></li><li><a href="types/other-index.html"><strong aria-hidden="true">3.2.</strong> 其他类型</a></li><li><ol class="section"><li><a href="types/enums.html"><strong aria-hidden="true">3.2.1.</strong> 枚举</a></li><li><a href="types/interfaces.html"><strong aria-hidden="true">3.2.2.</strong> 接口</a></li><li><a href="types/input_objects.html"><strong aria-hidden="true">3.2.3.</strong> 输入对象</a></li><li><a href="types/scalars.html"><strong aria-hidden="true">3.2.4.</strong> 标量</a></li><li><a href="types/unions.html"><strong aria-hidden="true">3.2.5.</strong> 联合</a></li></ol></li></ol></li><li><a href="schema/schemas_and_mutations.html"><strong aria-hidden="true">4.</strong> Schemas and mutations</a></li><li><a href="servers/index.html"><strong aria-hidden="true">5.</strong> Adding A Server</a></li><li><ol class="section"><li><a href="servers/official.html"><strong aria-hidden="true">5.1.</strong> Official Server Integrations</a></li><li><ol class="section"><li><a href="servers/warp.html"><strong aria-hidden="true">5.1.1.</strong> Warp</a></li><li><a href="servers/rocket.html"><strong aria-hidden="true">5.1.2.</strong> Rocket</a></li><li><a href="servers/iron.html"><strong aria-hidden="true">5.1.3.</strong> Iron</a></li><li><a href="servers/hyper.html"><strong aria-hidden="true">5.1.4.</strong> Hyper</a></li></ol></li><li><a href="servers/third-party.html"><strong aria-hidden="true">5.2.</strong> Third Party Integrations</a></li></ol></li><li><a href="advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Topics</a></li><li><ol class="section"><li><a href="advanced/introspection.html"><strong aria-hidden="true">6.1.</strong> Introspection</a></li><li><a href="advanced/non_struct_objects.html"><strong aria-hidden="true">6.2.</strong> Non-struct objects</a></li><li><a href="advanced/objects_and_generics.html"><strong aria-hidden="true">6.3.</strong> Objects and generics</a></li><li><a href="advanced/multiple_ops_per_request.html"><strong aria-hidden="true">6.4.</strong> Multiple operations per request</a></li><li class="spacer"></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Juniper - Rust 语言的 GraphQL 服务器</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#juniper-中文手册同步最新开发版" id="juniper-中文手册同步最新开发版">Juniper 中文手册（同步最新开发版）</a></h1>
<p><a href="https://juniper.budshome.com">Juniper 中文手册（同步最新开发版）-https://juniper.budshome.com</a> 包含 <code>Juniper</code> 中文文档和代码示例，内容译自 <a href="https://github.com/graphql-rust/juniper/tree/master/docs/book">graphql-rust/juniper 官方文档</a>。</p>
<p>💥 <strong>更新时间：2019-08-27</strong></p>
<hr />
<h2><a class="header" href="#做贡献" id="做贡献">做贡献</a></h2>
<h3><a class="header" href="#需求" id="需求">需求</a></h3>
<p>本手册由 <a href="https://github.com/rust-lang-nursery/mdBook">mdBook</a> 编译而成。</p>
<p>如果已有 <code>Rust</code> 环境，安装 <code>mdBook</code> 请执行命令：</p>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<h3><a class="header" href="#启动本地测试服务器" id="启动本地测试服务器">启动本地测试服务器</a></h3>
<p>启动持续编译手册并自动加载页面的本地测试服务器，执行命令：</p>
<pre><code class="language-bash">mdbook serve
</code></pre>
<h3><a class="header" href="#生成手册" id="生成手册">生成手册</a></h3>
<p>将手册渲染输出为 <code>HTML</code>，执行命令：</p>
<pre><code class="language-bash">mdbook build
</code></pre>
<p>输出目录为：<code>./docs</code>。</p>
<h3><a class="header" href="#测试" id="测试">测试</a></h3>
<p>测试手册中的所有代码示例，运行命令：</p>
<pre><code class="language-bash">cd ./tests
cargo test
</code></pre>
<h3><a class="header" href="#测试配置" id="测试配置">测试配置</a></h3>
<p>手册中的所有 <code>Rust</code> 代码示例在 <code>CI</code> 上编译，使用了  <a href="https://github.com/budziq/rust-skeptic">skeptic</a> 库。</p>
<h2><a class="header" href="#声明" id="声明">声明</a></h2>
<p>水平有限，错漏难免，欢迎指教；或请发 <a href="https://github.com/zzy/juniper-book-zh">issue到GitHub</a>；或者直接联系。</p>
<blockquote>
<p>电子邮箱：linshi@budshome.com；微信：cd-zzy；QQ：9809920。</p>
</blockquote>
<p>感谢<code>graphql-rust/juniper 团队</code>的无私奉献。</p>
<p>💥 笔者无意侵犯任何人的权利和利益，故若有不适，请联系我。</p>
<hr />
<h1><a class="header" href="#juniper" id="juniper">Juniper</a></h1>
<blockquote>
<p><a href="https://github.com/graphql-rust/juniper/blob/master/docs/book/content/README.md">README.md</a>
<br />
commit 9623e4d32694118e68ce8706f29e2cfbc6c5b6dc</p>
</blockquote>
<p>Juniper 是 Rust 语言的 <a href="http://graphql.org">GraphQL</a> 服务器库，用最少量的样板文件和配置构建类型安全且快速的 API 服务器。</p>
<p><a href="http://graphql.org">GraphQL</a> 是Facebook开发的一种数据查询语言，旨在为移动和 Web 应用程序前端提供服务。</p>
<p><em>Juniper</em> 使得以 Rust 语言编写类型安全且速度惊人的 GraphQL 服务器成为可能，我们还尝试尽可能方便地声明和解析 GraphQL 模式。</p>
<p>Juniper 不包含 Web 服务器，仅提供了构建快，使得其与已有服务器的集成简单明了。Juniper 可选地为 <a href="https://hyper.rs">Hyper</a>、<a href="http://ironframework.io">Iron</a>、<a href="https://rocket.rs">Rocket</a>，以及 <a href="https://github.com/seanmonstar/warp">Warp</a>等框架提供了预构建集成，并嵌入了 <a href="https://github.com/graphql/graphiql">Graphiql</a>，以便于调试。</p>
<p><em><strong>译者注：</strong></em> 对于 Juniper 团队没有提供预集成的 Web 框架，如 <a href="https://github.com/actix/actix-web">actix-web</a>，其构建集成也很简单，<a href="https://github.com/actix/actix-web">actix-web</a> 用户提供了完整集成实例。</p>
<ul>
<li><a href="https://crates.io/crates/juniper">Cargo crate</a></li>
<li><a href="https://docs.rs/juniper">API Reference</a></li>
</ul>
<h2><a class="header" href="#特点" id="特点">特点</a></h2>
<p>Juniper 根据 <a href="http://facebook.github.io/graphql">GraphQL 规范定义</a>支持完整的 GraphQL 查询语言，包括：接口、联合、模式内省，以及验证。但是不支持模式语言。</p>
<p>Juniper 作为 Rust 语言的 GraphQL 库，默认构建非空类型。类型为 <code>Vec&lt;Episode&gt;</code> 的字段将被转换为 <code>[Episode!]!</code>，相应的 Rust 语言类型则为 <code>Option&lt;Vec&lt;Option&lt;Episode&gt;&gt;&gt;</code>。</p>
<h2><a class="header" href="#集成" id="集成">集成</a></h2>
<h3><a class="header" href="#数据类型" id="数据类型">数据类型</a></h3>
<p>Juniper 与一些较常见的 Rust 库进行了自动集成，使构建模式变得简单，被集成的 Rust 库中的类型将在 GraphQL 模式中自动可用。</p>
<ul>
<li><a href="https://crates.io/crates/uuid">uuid</a></li>
<li><a href="https://crates.io/crates/url">url</a></li>
<li><a href="https://crates.io/crates/chrono">chrono</a></li>
</ul>
<h3><a class="header" href="#web-框架" id="web-框架">Web 框架</a></h3>
<ul>
<li><a href="https://hyper.rs">hyper</a></li>
<li><a href="https://rocket.rs">rocket</a></li>
<li><a href="http://ironframework.io">iron</a></li>
<li><a href="https://github.com/seanmonstar/warp">warp</a></li>
</ul>
<h2><a class="header" href="#api-稳定性" id="api-稳定性">API 稳定性</a></h2>
<p>Juniper 还未发布 1.0 版本，部分 API 稳定性可能不够成熟。</p>
<h1><a class="header" href="#快速入门" id="快速入门">快速入门</a></h1>
<blockquote>
<p><a href="https://github.com/graphql-rust/juniper/blob/master/docs/book/content/quickstart.md">quickstart.md</a>
<br />
commit 29025e6cae4a249fa56017dcf16b95ee4e89363e</p>
</blockquote>
<p>简要介绍 Juniper 中的概念。</p>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<p>!文件名 Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;^0.13.1&quot;
</code></pre>
<h2><a class="header" href="#模式示例" id="模式示例">模式示例</a></h2>
<p>要将 Rust 语言的 <code>enums</code> 和 <code>structs</code> 暴露为 GraphQL，仅需向其增加一个自定义<code>派生属性</code>。Juniper 支持将 Rust 语言基本类型轻而易举地映射到 GraphQL 特性，诸如：<code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>String</code>、<code>f64</code> 和 <code>i32</code>、<code>引用</code>和<code>切片（slice）</code>.</p>
<p>对于更高级的映射，Juniper 提供了多种<code>宏（macro）</code>来将 Rust 类型映射到 GraphQL 模式。<a href="https://docs.rs/juniper/latest/juniper/macro.object.html">过程宏对象</a>是最重要的宏对象之一，其用于声明解析器对象，您将使用解析器对象来 <code>查询（Query）</code> 和 <code>变更（Mutation）</code> 根（roots）。</p>
<pre><pre class="playpen"><code class="language-rust">use juniper::{FieldResult};

# struct DatabasePool;
# impl DatabasePool {
#     fn get_connection(&amp;self) -&gt; FieldResult&lt;DatabasePool&gt; { Ok(DatabasePool) }
#     fn find_human(&amp;self, _id: &amp;str) -&gt; FieldResult&lt;Human&gt; { Err(&quot;&quot;)? }
#     fn insert_human(&amp;self, _human: &amp;NewHuman) -&gt; FieldResult&lt;Human&gt; { Err(&quot;&quot;)? }
# }

#[derive(juniper::GraphQLEnum)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

#[derive(juniper::GraphQLObject)]
#[graphql(description=&quot;星球大战中的类人生物&quot;)]
struct Human {
    id: String,
    name: String,
    appears_in: Vec&lt;Episode&gt;,
    home_planet: String,
}

// 另一个用于映射 GraphQL 输入对象的自定义派生。

#[derive(juniper::GraphQLInputObject)]
#[graphql(description=&quot;星球大战中的类人生物&quot;)]
struct NewHuman {
    name: String,
    appears_in: Vec&lt;Episode&gt;,
    home_planet: String,
}

// 使用宏对象创建带有解析器的根查询和根变更。
// 对象可以拥有类似数据库池一样的允许访问共享状态的上下文。

struct Context {
    // 这里使用真实数据池
    pool: DatabasePool,
}

// 要让 Juniper 使用上下文，必须实现标注特性（trait）
impl juniper::Context for Context {}

struct Query;

#[juniper::object(
    // 指定对象的上下文类型。
    // 需要访问上下文的每种类型都需如此。
    Context = Context,
)]
impl Query {

    fn apiVersion() -&gt; &amp;str {
        &quot;1.0&quot;
    }

    // 解析器的参数可以是简单类型，也可以是输入对象。
    // 为了访问上下文，我们指定了一个引用上下文类型的参数。
    // Juniper 会自动注入正确的上下文。
    fn human(context: &amp;Context, id: String) -&gt; FieldResult&lt;Human&gt; {
        // 获取数据库连接
        let connection = context.pool.get_connection()?;
        // 执行查询
        // 注意 `?` 的用法，进行错误传播。
        // 译者注：上一章“特点”中提到，Juniper 默认构建非空类型
        let human = connection.find_human(&amp;id)?;
        // 返回结果集
        Ok(human)
    }
}

// 下面对变更类型做同样的事情

struct Mutation;

#[juniper::object(
    Context = Context,
)]
impl Mutation {

    fn createHuman(context: &amp;Context, new_human: NewHuman) -&gt; FieldResult&lt;Human&gt; {
        let db = executor.context().pool.get_connection()?;
        let human: Human = db.insert_human(&amp;new_human)?;
        Ok(human)
    }
}

// 根模式由查询和变更组成，故查询请求可以执行于 RootNode。
type Schema = juniper::RootNode&lt;'static, Query, Mutation&gt;;

# fn main() {
#   let _ = Schema::new(Query, Mutation{});
# }
</code></pre></pre>
<p>现在，我们有了一个非常简单，但模式功能齐全的 GraphQL服务器。</p>
<p>要让此模式在服务器端起作用，查阅各类<a href="./servers/index.html">服务器集成</a>指南。</p>
<p>也可以直接调用执行器（executor）来获取查询结果集：</p>
<h2><a class="header" href="#执行器executor" id="执行器executor">执行器（executor）</a></h2>
<p>可以直接调用 <code>juniper::execute</code> 来运行 GraphQL 查询：</p>
<pre><pre class="playpen"><code class="language-rust"># // 由于宏（macro）不可访问，如下代码仅 Rust-2018 版需要
# #[macro_use] extern crate juniper;
use juniper::{FieldResult, Variables, EmptyMutation};


#[derive(juniper::GraphQLEnum, Clone, Copy)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

// 上下文（context）数据
struct Ctx(Episode);

impl juniper::Context for Ctx {}

struct Query;

#[juniper::object(
    Context = Ctx,
)]
impl Query {
    fn favoriteEpisode(context: &amp;Ctx) -&gt; FieldResult&lt;Episode&gt; {
        Ok(context.0)
    }
}


// 根模式由查询和变更组成，故查询请求可以执行于 RootNode。
type Schema = juniper::RootNode&lt;'static, Query, EmptyMutation&lt;Ctx&gt;&gt;;

fn main() {
    // 创建上下文对象
    let ctx = Ctx(Episode::NewHope);

    // 运行执行器
    let (res, _errors) = juniper::execute(
        &quot;query { favoriteEpisode }&quot;,
        None,
        &amp;Schema::new(Query, EmptyMutation::new()),
        &amp;Variables::new(),
        &amp;ctx,
    ).unwrap();

    // 确保查询结果值匹配
    assert_eq!(
        res,
        graphql_value!({
            &quot;favoriteEpisode&quot;: &quot;NEW_HOPE&quot;,
        })
    );
}
</code></pre></pre>
<h1><a class="header" href="#type-system" id="type-system">Type System</a></h1>
<blockquote>
<p><a href="https://github.com/graphql-rust/juniper/blob/master/docs/book/content/types/index.md">types/index.md</a>
<br />
commit a75396846d9f8930d1e07e972a91ff59308e77cf</p>
</blockquote>
<p>使用 Juniper 的大部分工作包括将 GraphQL 类型系统映射到应用程序使用的 Rust 语言类型。</p>
<p>Juniper提供了一些恰当方便的抽象，力图使这个过程尽可能地简单。</p>
<p>下面的章节可以查阅更多信息。</p>
<ul>
<li><a href="types/objects/defining_objects.html">对象定义</a>
<ul>
<li><a href="types/objects/complex_fields.html">复杂字段</a></li>
<li><a href="types/objects/using_contexts.html">上下文</a></li>
<li><a href="types/objects/error_handling.html">错误处理</a></li>
</ul>
</li>
<li><a href="types/other-index.html">其他类型</a>
<ul>
<li><a href="types/enums.html">枚举</a></li>
<li><a href="types/interfaces.html">接口</a></li>
<li><a href="types/input_objects.html">输入对象</a></li>
<li><a href="types/scalars.html">标量</a></li>
<li><a href="types/unions.html">联合</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#定义对象" id="定义对象">定义对象</a></h1>
<blockquote>
<p><a href="https://github.com/graphql-rust/juniper/blob/master/docs/book/content/types/objects/defining_objects.md">types/objects/defining_objects.md</a>
<br />
commit 693405afa5a86df3a2277065696e7c42306ff630</p>
</blockquote>
<p>尽管 Rust 中的任何类型都可以暴露为 GraphQL 对象，但最常见的类型是结构体（struct）。</p>
<p>Juniper 中，有两种方式创建 GraphQL对象：如果想要暴露一个简单结构体（struct），最简单的方式是自定义派生属性；另外一种方式将在<a href="types/objects/complex_fields.html">复杂字段</a>章节中介绍。</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}

# fn main() {}
</code></pre></pre>
<p>上述代码将创建一个名为 <code>Person</code> 的 GraphQL 对象，有两个字段：<code>String!</code> 类型的 <code>name</code>，<code>Int!</code> 类型的  <code>age</code>。Rust 语言类型系统中，变量绑定默认为非空（non-null）。若您需要可空（nullable）字段，可以使用 <code>Option&lt;T&gt;</code>。</p>
<p>我们应当利用 GraphQL 是自文档化（self-documenting）的特点，向类型和字段添加描述。Juniper 将自动使用关联的 Rust 文档注释作为 GraphQL 描述：</p>
<p>!文件名 通过 Rust 文档注释作为 GraphQL 描述</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
/// 个人信息
struct Person {
    /// 个人全名，包括姓氏和名字
    name: String,
    /// 个人年龄，以年为单位，按月份四舍五入
    age: i32,
}

# fn main() {}
</code></pre></pre>
<p>Rust 中不能使用文档注释的对象和字段，可通过 <code>graphql</code> 属性设置<code>描述</code>。如下示例和上述代码等价：</p>
<p>!文件名 通过 graphql 属性设置描述</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
#[graphql(description=&quot;个人信息&quot;)]
struct Person {
    #[graphql(description=&quot;个人全名，包括姓氏和名字&quot;)]
    name: String,
    #[graphql(description=&quot;个人年龄，以年为单位，按月份四舍五入&quot;)]
    age: i32,
}

# fn main() {}
</code></pre></pre>
<p>通过 <code>graphql</code> 属性设置的描述优先于 Rust 文档注释，这使得内部 Rust 文档和外部 GraphQL 文档能够不同：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
#[graphql(description=&quot;这段描述展示在 GraphQL&quot;)]
/// 这段描述展示在 RustDoc
struct Person {
    #[graphql(description=&quot;这段描述展示在 GraphQL&quot;)]
    /// 这段描述展示在 RustDoc
    name: String,
    /// 这段描述在 RustDoc 和 GraphQL 中都展示
    age: i32,
}

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#关系" id="关系">关系</a></h2>
<p>如下情形，只能使用自定义派生属性：</p>
<ul>
<li>注解类型是<code>结构体（struct）</code>,</li>
<li>结构体的字段符合以下情形——
<ul>
<li>简单类型（<code>i32</code>, <code>f64</code>, <code>bool</code>, <code>String</code>, <code>juniper::ID</code>）；或者</li>
<li>有效的自定义 GraphQL 类型，如使用此属性标记了其他结构体字段；或者</li>
<li>容器/引用包含以上情形之一，如 <code>Vec&lt;T&gt;</code>、<code>Box&lt;T&gt;</code>、<code>Option&lt;T&gt;</code>。</li>
</ul>
</li>
</ul>
<p>让我们看看这对于对象之间的构建关系意味着什么：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}

#[derive(juniper::GraphQLObject)]
struct House {
    address: Option&lt;String&gt;, // 转换为字符串（可空）
    inhabitants: Vec&lt;Person&gt;, // 转换为 [Person!]!
}

# fn main() {}
</code></pre></pre>
<p>因为 <code>Person</code> 是一个有效的 GraphQL 类型，所以可以在另一个结构体中使用 <code>Vec&lt;Person&gt;</code>，它将自动转换为 <code>非空 Person 对象</code> 的列表。</p>
<h2><a class="header" href="#字段重命名" id="字段重命名">字段重命名</a></h2>
<p>默认地，结构体字段由 Rust 标准命名约定<code>蛇形命名法（snake_case）</code>被转换为 GraphQL 约定的<code>驼峰命名法（snake_case）</code>：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    first_name: String, // GraphQL 模式中将被暴露为 firstName
    last_name: String, // GraphQL 模式中将被暴露为 lastName
}

# fn main() {}
</code></pre></pre>
<p>可以在某个结构体字段上使用 <code>graphql</code> 属性指定名称：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(name=&quot;websiteURL&quot;)]
    website_url: Option&lt;String&gt;, // GraphQL 模式中将被暴露为 websiteURL
}

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#字段弃用" id="字段弃用">字段弃用</a></h2>
<p>要弃用字段，可使用 <code>graphql</code> 属性指定弃用原因：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(deprecated = &quot;请使用 name 字段代替&quot;)]
    first_name: String,
}

# fn main() {}
</code></pre></pre>
<p>当然，<code>名称（name）</code>、<code>描述(description)</code>和<code>deprecation（弃用）</code>参数可以组合使用。不过 GraphQL 规范中的一些限制依然存在，<code>deprecation（弃用）</code>参数只能用于对象字段和枚举值。</p>
<h2><a class="header" href="#字段忽略" id="字段忽略">字段忽略</a></h2>
<p>默认地，<code>GraphQLObject</code> 中的所有字段都包含在生成的 GraphQL 类型中。若要不包含特定字段，请使用注解 <code>#[graphql(skip)]</code>：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
    #[graphql(skip)]
    # #[allow(dead_code)]
    password_hash: String, // 此字段不能从 GraphQL 查询或修改
}

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#复杂字段" id="复杂字段">复杂字段</a></h1>
<blockquote>
<p><a href="https://github.com/graphql-rust/juniper/blob/master/docs/book/content/types/objects/complex_fields.md">types/objects/complex_fields.md</a>
<br />
commit cff6036206da12f9a4cbddb869569e9a977fa2ef</p>
</blockquote>
<p>如果您有一个不能直接映射到 GraphQL 的结构体（struct），其中包含计算字段或循环结构，那么您必须使用一个更强大的工具：<code>过程宏对象</code>。过程宏允许您在 Rust <code>impl</code> 块中为类型定义 GraphQL 对象字段。让我们继续上一章的示例，学习如何使用宏定义 <code>Person</code>：</p>
<pre><pre class="playpen"><code class="language-rust">
struct Person {
    name: String,
    age: i32,
}

#[juniper::object]
impl Person {
    fn name(&amp;self) -&gt; &amp;str {
        self.name.as_str()
    }

    fn age(&amp;self) -&gt; i32 {
        self.age
    }
}

# fn main() { }
</code></pre></pre>
<p>虽然上述示例代码有点冗长，但它允许您在字段解析器中编写任何类型的函数。同时，使用上述示例语法，字段可以接受参数：</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Person {
    name: String,
    age: i32,
}

struct House {
    inhabitants: Vec&lt;Person&gt;,
}

#[juniper::object]
impl House {
    // 创建字段 inhabitantWithName(name), 返回非空 person
    fn inhabitant_with_name(&amp;self, name: String) -&gt; Option&lt;&amp;Person&gt; {
        self.inhabitants.iter().find(|p| p.name == name)
    }
}

# fn main() {}
</code></pre></pre>
<p>要访问诸如数据库连接或身份验证信息之类的全局数据，需要使用 <em>上下文（context）</em>。更多关于 <em>上下文（context）</em> 的信息，将在下一章介绍：<a href="types/objects/using_contexts.html">上下文</a>。</p>
<h2><a class="header" href="#描述重命名以及弃用" id="描述重命名以及弃用">描述、重命名，以及弃用</a></h2>
<p>与派生属性一样，字段名将从命名约定 <code>snake_case</code> 转换为 <code>camelCase</code>。若需重写转换，可以简单地重命名字段。此外，可以使用别名更换类型名称：</p>
<pre><pre class="playpen"><code class="language-rust">
struct Person {
}

/// Rust 文档注释用作 GraphQL 描述。
#[juniper::object(
    // 使用 name 属性，可以更改 GraphQL 类型的公开名称。
    name = &quot;PersonObject&quot;,
    // 可以在此处指定 GraphQL 描述，这将覆盖 Rust 文档注释。
    description = &quot;...&quot;,
)]
impl Person {

    /// 字段上的文档注释被用作 GraphQL 描述
    #[graphql(
        // 或者指定 GraphQL 描述
        description = &quot;...&quot;,
    )]
    fn doc_comment(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }

    // 如果需要，字段也可以使用 name 属性来重命名
    #[graphql(
        name = &quot;myCustomFieldName&quot;,
    )]
    fn renamed_field() -&gt; bool {
        true
    }

    // 如期望的那样，弃用也有效。
    // 即可以接受标准的 Rust 语法，也可以接受自定义属性。
    #[deprecated(note = &quot;...&quot;)]
    fn deprecated_standard() -&gt; bool {
        false
    }

    #[graphql(deprecated = &quot;...&quot;)]
    fn deprecated_graphql() -&gt; bool {
        true
    }
}

# fn main() { }
</code></pre></pre>
<h2><a class="header" href="#自定义参数" id="自定义参数">自定义参数</a></h2>
<p>方法的字段参数也是可以定制的，可以指定自定义描述和默认值。</p>
<p><strong>注</strong>：这个语法目前有点别扭。一旦实现了<a href="https://github.com/rust-lang/rust/issues/60406">Rust RFC 2565</a>，将会变得好用。</p>
<pre><pre class="playpen"><code class="language-rust">
struct Person {}

#[juniper::object]
impl Person {
    #[graphql(
        arguments(
            arg1(
                // Set a default value which will be injected if not present.
                // The default can be any valid Rust expression, including a function call, etc.
                default = true,
                // Set a description.
                description = &quot;The first argument...&quot;
            ),
            arg2(
                default = 0,
            )
        )
    )]
    fn field1(&amp;self, arg1: bool, arg2: i32) -&gt; String {
        format!(&quot;{} {}&quot;, arg1, arg2)
    }
}

# fn main() { }
</code></pre></pre>
<h2><a class="header" href="#more-features" id="more-features">More features</a></h2>
<p>GraphQL fields expose more features than Rust’s standard method syntax gives us:</p>
<ul>
<li>Per-field description and deprecation messages</li>
<li>Per-argument default values</li>
<li>Per-argument descriptions</li>
</ul>
<p>These, and more features, are described more thorougly in <a href="https://docs.rs/juniper/latest/juniper/macro.object.html">the reference
documentation</a>.</p>
<h1><a class="header" href="#using-contexts" id="using-contexts">Using contexts</a></h1>
<p>The context type is a feature in Juniper that lets field resolvers access global
data, most commonly database connections or authentication information. The
context is usually created from a <em>context factory</em>. How this is defined is
specific to the framework integration you’re using, so check out the
documentation for either the <a href="types/objects/../../servers/iron.html">Iron</a> or <a href="types/objects/../../servers/rocket.html">Rocket</a>
integration.</p>
<p>In this chapter, we’ll show you how to define a context type and use it in field
resolvers. Let’s say that we have a simple user database in a <code>HashMap</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(dead_code)]
# use std::collections::HashMap;

struct Database {
    users: HashMap&lt;i32, User&gt;,
}

struct User {
    id: i32,
    name: String,
    friend_ids: Vec&lt;i32&gt;,
}

# fn main() { }
</code></pre></pre>
<p>We would like a <code>friends</code> field on <code>User</code> that returns a list of <code>User</code> objects.
In order to write such a field though, the database must be queried.</p>
<p>To solve this, we mark the <code>Database</code> as a valid context type and assign it to
the user object. </p>
<p>To gain access to the context, we need to specify an argument with the same 
type as the specified <code>Context</code> for the type:</p>
<pre><pre class="playpen"><code class="language-rust"># use std::collections::HashMap;
extern crate juniper;

// This struct represents our context.
struct Database {
    users: HashMap&lt;i32, User&gt;,
}

// Mark the Database as a valid context type for Juniper
impl juniper::Context for Database {}

struct User {
    id: i32,
    name: String,
    friend_ids: Vec&lt;i32&gt;,
}


// Assign Database as the context type for User
#[juniper::object(
    Context = Database,
)]
impl User {
    // 3. Inject the context by specifying an argument
    //    with the context type.
    // Note: 
    //   - the type must be a reference
    //   - the name of the argument SHOULD be context
    fn friends(&amp;self, context: &amp;Database) -&gt; Vec&lt;&amp;User&gt; {

        // 5. Use the database to lookup users
        self.friend_ids.iter()
            .map(|id| context.users.get(id).expect(&quot;Could not find user with ID&quot;))
            .collect()
    }

    fn name(&amp;self) -&gt; &amp;str { 
        self.name.as_str() 
    }

    fn id(&amp;self) -&gt; i32 { 
        self.id 
    }
}

# fn main() { }
</code></pre></pre>
<p>You only get an immutable reference to the context, so if you want to affect
change to the execution, you’ll need to use <a href="https://doc.rust-lang.org/book/first-edition/mutability.html#interior-vs-exterior-mutability">interior
mutability</a>
using e.g. <code>RwLock</code> or <code>RefCell</code>.</p>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Rust
<a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">provides</a>
two ways of dealing with errors: <code>Result&lt;T, E&gt;</code> for recoverable errors and
<code>panic!</code> for unrecoverable errors. Juniper does not do anything about panicking;
it will bubble up to the surrounding framework and hopefully be dealt with
there.</p>
<p>For recoverable errors, Juniper works well with the built-in <code>Result</code> type, you
can use the <code>?</code> operator or the <code>try!</code> macro and things will generally just work
as you expect them to:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate juniper;
use std::{
    str,
    path::PathBuf,
    fs::{File},
    io::{Read},
};
use juniper::FieldResult;

struct Example {
    filename: PathBuf,
}

#[juniper::object]
impl Example {
    fn contents() -&gt; FieldResult&lt;String&gt; {
        let mut file = File::open(&amp;self.filename)?;
        let mut contents = String::new();
        file.read_to_string(&amp;mut contents)?;
        Ok(contents)
    }

    fn foo() -&gt; FieldResult&lt;Option&lt;String&gt;&gt; {
      // Some invalid bytes.
      let invalid = vec![128, 223];

      match str::from_utf8(&amp;invalid) {
        Ok(s) =&gt; Ok(Some(s.to_string())),
        Err(e) =&gt; Err(e)?,
      }
    }
}

# fn main() {}
</code></pre></pre>
<p><code>FieldResult&lt;T&gt;</code> is an alias for <code>Result&lt;T, FieldError&gt;</code>, which is the error
type all fields must return. By using the <code>?</code> operator or <code>try!</code> macro, any type
that implements the <code>Display</code> trait - which are most of the error types out
there - those errors are automatically converted into <code>FieldError</code>.</p>
<p>When a field returns an error, the field’s result is replaced by <code>null</code>, an
additional <code>errors</code> object is created at the top level of the response, and the
execution is resumed. For example, with the previous example and the following
query:</p>
<pre><code class="language-graphql">{
  example {
    contents
    foo
  }
}
</code></pre>
<p>If <code>str::from_utf8</code> resulted in a <code>std::str::Utf8Error</code>, the following would be
returned:</p>
<p>!FILENAME Response for nullable field with error</p>
<pre><code class="language-js">{
  &quot;data&quot;: {
    &quot;example&quot;: {
      contents: &quot;&lt;Contents of the file&gt;&quot;,
      foo: null,
    }
  },
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;invalid utf-8 sequence of 2 bytes from index 0&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<p>If an error is returned from a non-null field, such as the
example above, the <code>null</code> value is propagated up to the first nullable parent
field, or the root <code>data</code> object if there are no nullable fields.</p>
<p>For example, with the following query:</p>
<pre><code class="language-graphql">{
  example {
    contents
  }
}
</code></pre>
<p>If <code>File::open()</code> above resulted in <code>std::io::ErrorKind::PermissionDenied</code>, the
following would be returned:</p>
<p>!FILENAME Response for non-null field with error and no nullable parent</p>
<pre><code class="language-js">{
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;Permission denied (os error 13)&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<h2><a class="header" href="#structured-errors" id="structured-errors">Structured errors</a></h2>
<p>Sometimes it is desirable to return additional structured error information
to clients. This can be accomplished by implementing <a href="https://docs.rs/juniper/latest/juniper/trait.IntoFieldError.html"><code>IntoFieldError</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust"># #[macro_use] extern crate juniper;
enum CustomError {
    WhateverNotSet,
}

impl juniper::IntoFieldError for CustomError {
    fn into_field_error(self) -&gt; juniper::FieldError {
        match self {
            CustomError::WhateverNotSet =&gt; juniper::FieldError::new(
                &quot;Whatever does not exist&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;NO_WHATEVER&quot;
                }),
            ),
        }
    }
}

struct Example {
    whatever: Option&lt;bool&gt;,
}

#[juniper::object]
impl Example {
    fn whatever() -&gt; Result&lt;bool, CustomError&gt; {
      if let Some(value) = self.whatever {
        return Ok(value);
      }
      Err(CustomError::WhateverNotSet)
    }
}

# fn main() {}
</code></pre></pre>
<p>The specified structured error information is included in the <a href="https://facebook.github.io/graphql/June2018/#sec-Errors"><code>extensions</code></a> key:</p>
<pre><code class="language-js">{
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;Whatever does not exist&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }]),
    &quot;extensions&quot;: {
      &quot;type&quot;: &quot;NO_WHATEVER&quot;
    }
  ]
}
</code></pre>
<h1><a class="header" href="#other-types" id="other-types">Other Types</a></h1>
<p>The GraphQL type system provides several types in additon to objects.</p>
<p>Find out more about each type below:</p>
<ul>
<li><a href="types/enums.html">Enums</a></li>
<li><a href="types/interfaces.html">Interfaces</a></li>
<li><a href="types/input_objects.html">Input objects</a></li>
<li><a href="types/scalars.html">Scalars</a></li>
<li><a href="types/unions.html">Unions</a></li>
</ul>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>Enums in GraphQL are string constants grouped together to represent a set of
possible values. Simple Rust enums can be converted to GraphQL enums by using a
custom derive attribute:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLEnum)]
enum Episode {
    NewHope,
    Empire,
    Jedi,
}

# fn main() {}
</code></pre></pre>
<p>Juniper converts all enum variants to uppercase, so the corresponding string
values for these variants are <code>NEWHOPE</code>, <code>EMPIRE</code>, and <code>JEDI</code>, respectively. If
you want to override this, you can use the <code>graphql</code> attribute, similar to how
it works when <a href="types/objects/defining_objects.html">defining objects</a>:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLEnum)]
enum Episode {
    #[graphql(name=&quot;NEW_HOPE&quot;)]
    NewHope,
    Empire,
    Jedi,
}

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#documentation-and-deprecation" id="documentation-and-deprecation">Documentation and deprecation</a></h2>
<p>Just like when defining objects, the type itself can be renamed and documented,
while individual enum variants can be renamed, documented, and deprecated:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLEnum)]
#[graphql(name=&quot;Episode&quot;, description=&quot;An episode of Star Wars&quot;)]
enum StarWarsEpisode {
    #[graphql(deprecated=&quot;We don't really talk about this one&quot;)]
    ThePhantomMenace,

    #[graphql(name=&quot;NEW_HOPE&quot;)]
    NewHope,

    #[graphql(description=&quot;Arguably the best one in the trilogy&quot;)]
    Empire,
    Jedi,
}

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#interfaces" id="interfaces">Interfaces</a></h1>
<p>GraphQL interfaces map well to interfaces known from common object-oriented
languages such as Java or C#, but Rust has unfortunately not a concept that maps
perfectly to them. Because of this, defining interfaces in Juniper can require a
little bit of boilerplate code, but on the other hand gives you full control
over which type is backing your interface.</p>
<p>To highlight a couple of different ways you can implement interfaces in Rust,
let’s have a look at the same end-result from a few different implementations:</p>
<h2><a class="header" href="#traits" id="traits">Traits</a></h2>
<p>Traits are maybe the most obvious concept you want to use when building
interfaces. But because GraphQL supports downcasting while Rust doesn’t, you’ll
have to manually specify how to convert a trait into a concrete type. This can
be done in a couple of different ways:</p>
<h3><a class="header" href="#downcasting-via-accessor-methods" id="downcasting-via-accessor-methods">Downcasting via accessor methods</a></h3>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

trait Character {
    fn id(&amp;self) -&gt; &amp;str;

    // Downcast methods, each concrete class will need to implement one of these
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { None }
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { None }
}

impl Character for Human {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { Some(&amp;self) }
}

impl Character for Droid {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { Some(&amp;self) }
}

juniper::graphql_interface!(&lt;'a&gt; &amp;'a Character: () as &quot;Character&quot; where Scalar = &lt;S&gt; |&amp;self| {
    field id() -&gt; &amp;str { self.id() }

    instance_resolvers: |_| {
        // The left hand side indicates the concrete type T, the right hand
        // side should be an expression returning Option&lt;T&gt;
        &amp;Human =&gt; self.as_human(),
        &amp;Droid =&gt; self.as_droid(),
    }
});

# fn main() {}
</code></pre></pre>
<p>The <code>instance_resolvers</code> declaration lists all the implementors of the given
interface and how to resolve them.</p>
<p>As you can see, you lose a bit of the point with using traits: you need to list
all the concrete types in the trait itself, and there’s a bit of repetition
going on.</p>
<h3><a class="header" href="#using-an-extra-database-lookup" id="using-an-extra-database-lookup">Using an extra database lookup</a></h3>
<p>If you can afford an extra database lookup when the concrete class is requested,
you can do away with the downcast methods and use the context instead. Here,
we’ll use two hashmaps, but this could be two tables and some SQL calls instead:</p>
<pre><pre class="playpen"><code class="language-rust"># use std::collections::HashMap;
#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}

impl juniper::Context for Database {}

trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}

impl Character for Human {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

impl Character for Droid {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

juniper::graphql_interface!(&lt;'a&gt; &amp;'a Character: Database as &quot;Character&quot; where Scalar = &lt;S&gt; |&amp;self| {
    field id() -&gt; &amp;str { self.id() }

    instance_resolvers: |&amp;context| {
        &amp;Human =&gt; context.humans.get(self.id()),
        &amp;Droid =&gt; context.droids.get(self.id()),
    }
});

# fn main() {}
</code></pre></pre>
<p>This removes the need of downcast methods, but still requires some repetition.</p>
<h2><a class="header" href="#placeholder-objects" id="placeholder-objects">Placeholder objects</a></h2>
<p>Continuing on from the last example, the trait itself seems a bit unneccesary.
Maybe it can just be a struct containing the ID?</p>
<pre><pre class="playpen"><code class="language-rust"># use std::collections::HashMap;
#[derive(juniper::GraphQLObject)]
#[graphql(Context = &quot;Database&quot;)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
#[graphql(Context = &quot;Database&quot;)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}

impl juniper::Context for Database {}

struct Character {
    id: String,
}

juniper::graphql_interface!(Character: Database where Scalar = &lt;S&gt; |&amp;self| {
    field id() -&gt; &amp;str { self.id.as_str() }

    instance_resolvers: |&amp;context| {
        &amp;Human =&gt; context.humans.get(&amp;self.id),
        &amp;Droid =&gt; context.droids.get(&amp;self.id),
    }
});

# fn main() {}
</code></pre></pre>
<p>This reduces repetition some more, but might be impractical if the interface’s
surface area is large. </p>
<h2><a class="header" href="#enums-1" id="enums-1">Enums</a></h2>
<p>Using enums and pattern matching lies half-way between using traits and using
placeholder objects. We don’t need the extra database call in this case, so
we’ll remove it.</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

# #[allow(dead_code)]
enum Character {
    Human(Human),
    Droid(Droid),
}

juniper::graphql_interface!(Character: () where Scalar = &lt;S&gt; |&amp;self| {
    field id() -&gt; &amp;str {
        match *self {
            Character::Human(Human { ref id, .. }) |
            Character::Droid(Droid { ref id, .. }) =&gt; id,
        }
    }

    instance_resolvers: |_| {
        &amp;Human =&gt; match *self { Character::Human(ref h) =&gt; Some(h), _ =&gt; None },
        &amp;Droid =&gt; match *self { Character::Droid(ref d) =&gt; Some(d), _ =&gt; None },
    }
});

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#input-objects" id="input-objects">Input objects</a></h1>
<p>Input objects are complex data structures that can be used as arguments to
GraphQL fields. In Juniper, you can define input objects using a custom derive
attribute, similar to simple objects and enums:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLInputObject)]
struct Coordinate {
    latitude: f64,
    longitude: f64
}

struct Root;
# #[derive(juniper::GraphQLObject)] struct User { name: String }

#[juniper::object]
impl Root {
    fn users_at_location(coordinate: Coordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Send coordinate to database
        // ...
# unimplemented!()
    }
}

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#documentation-and-renaming" id="documentation-and-renaming">Documentation and renaming</a></h2>
<p>Just like the <a href="types/objects/defining_objects.html">other</a> <a href="types/enums.html">derives</a>, you can rename
and add documentation to both the type and the fields:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLInputObject)]
#[graphql(name=&quot;Coordinate&quot;, description=&quot;A position on the globe&quot;)]
struct WorldCoordinate {
    #[graphql(name=&quot;lat&quot;, description=&quot;The latitude&quot;)]
    latitude: f64,

    #[graphql(name=&quot;long&quot;, description=&quot;The longitude&quot;)]
    longitude: f64
}

struct Root;
# #[derive(juniper::GraphQLObject)] struct User { name: String }

#[juniper::object]
impl Root {
    fn users_at_location(coordinate: WorldCoordinate, radius: f64) -&gt; Vec&lt;User&gt; {
        // Send coordinate to database
        // ...
# unimplemented!()
    }
}

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#scalars" id="scalars">Scalars</a></h1>
<p>Scalars are the primitive types at the leaves of a GraphQL query: numbers,
strings, and booleans. You can create custom scalars to other primitive values,
but this often requires coordination with the client library intended to consume
the API you’re building.</p>
<p>Since any value going over the wire is eventually transformed into JSON, you’re
also limited in the data types you can use. </p>
<p>There are two ways to define custom scalars. </p>
<ul>
<li>For simple scalars that just wrap a primitive type, you can use the newtype pattern with
a custom derive. </li>
<li>For more advanced use cases with custom validation, you can use
the <code>graphql_scalar!</code> macro.</li>
</ul>
<h2><a class="header" href="#built-in-scalars" id="built-in-scalars">Built-in scalars</a></h2>
<p>Juniper has built-in support for:</p>
<ul>
<li><code>i32</code> as <code>Int</code></li>
<li><code>f64</code> as <code>Float</code></li>
<li><code>String</code> and <code>&amp;str</code> as <code>String</code></li>
<li><code>bool</code> as <code>Boolean</code></li>
<li><code>juniper::ID</code> as <code>ID</code>. This type is defined <a href="http://facebook.github.io/graphql/#sec-ID">in the
spec</a> as a type that is serialized
as a string but can be parsed from both a string and an integer.</li>
</ul>
<p><strong>Third party types</strong>:</p>
<p>Juniper has built-in support for a few additional types from common third party
crates. They are enabled via features that are on by default.</p>
<ul>
<li>uuid::Uuid</li>
<li>chrono::DateTime</li>
<li>url::Url</li>
</ul>
<h2><a class="header" href="#newtype-pattern" id="newtype-pattern">newtype pattern</a></h2>
<p>Often, you might need a custom scalar that just wraps an existing type. </p>
<p>This can be done with the newtype pattern and a custom derive, similar to how
serde supports this pattern with <code>#[serde(transparent)]</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLScalarValue)]
pub struct UserId(i32);

#[derive(juniper::GraphQLObject)]
struct User {
    id: UserId,
}

# fn main() {}
</code></pre></pre>
<p>That’s it, you can now user <code>UserId</code> in your schema.</p>
<p>The macro also allows for more customization:</p>
<pre><pre class="playpen"><code class="language-rust">/// You can use a doc comment to specify a description.
#[derive(juniper::GraphQLScalarValue)]
#[graphql(
    transparent,
    // Overwrite the GraphQL type name.
    name = &quot;MyUserId&quot;,
    // Specify a custom description.
    // A description in the attribute will overwrite a doc comment.
    description = &quot;My user id description&quot;,
)]
pub struct UserId(i32);

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#custom-scalars" id="custom-scalars">Custom scalars</a></h2>
<p>For more complex situations where you also need custom parsing or validation, 
you can use the <code>graphql_scalar!</code> macro.</p>
<p>Typically, you represent your custom scalars as strings.</p>
<p>The example below implements a custom scalar for a custom <code>Date</code> type.</p>
<p>Note: juniper already has built-in support for the <code>chrono::DateTime</code> type 
via <code>chrono</code> feature, which is enabled by default and should be used for this 
purpose.</p>
<p>The example below is used just for illustration.</p>
<p><strong>Note</strong>: the example assumes that the <code>Date</code> type implements
<code>std::fmt::Display</code> and <code>std::str::FromStr</code>.</p>
<pre><pre class="playpen"><code class="language-rust"># mod date { 
#    pub struct Date; 
#    impl std::str::FromStr for Date{ 
#        type Err = String; fn from_str(_value: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; { unimplemented!() }
#    }
#    // And we define how to represent date as a string.
#    impl std::fmt::Display for Date {
#        fn fmt(&amp;self, _f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
#            unimplemented!()
#        }
#    }
# }

use juniper::{Value, ParseScalarResult, ParseScalarValue};
use date::Date;

juniper::graphql_scalar!(Date where Scalar = &lt;S&gt; {
    description: &quot;Date&quot;

    // Define how to convert your custom scalar into a primitive type.
    resolve(&amp;self) -&gt; Value {
        Value::scalar(self.to_string())
    }

    // Define how to parse a primitive type into your custom scalar.
    from_input_value(v: &amp;InputValue) -&gt; Option&lt;Date&gt; {
        v.as_scalar_value::&lt;String&gt;()
         .and_then(|s| s.parse().ok())
    }

    // Define how to parse a string value.
    from_str&lt;'a&gt;(value: ScalarToken&lt;'a&gt;) -&gt; ParseScalarResult&lt;'a, S&gt; {
        &lt;String as ParseScalarValue&lt;S&gt;&gt;::from_str(value)
    }
});

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#unions" id="unions">Unions</a></h1>
<p>From a server’s point of view, GraphQL unions are similar to interfaces: the
only exception is that they don’t contain fields on their own.</p>
<p>In Juniper, the <code>graphql_union!</code> has identical syntax to the <a href="types/interfaces.html">interface
macro</a>, but does not support defining fields. Therefore, the same
considerations about using traits, placeholder types, or enums still apply to
unions.</p>
<p>If we look at the same examples as in the interfaces chapter, we see the
similarities and the tradeoffs:</p>
<h2><a class="header" href="#traits-1" id="traits-1">Traits</a></h2>
<h3><a class="header" href="#downcasting-via-accessor-methods-1" id="downcasting-via-accessor-methods-1">Downcasting via accessor methods</a></h3>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

trait Character {
    // Downcast methods, each concrete class will need to implement one of these
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { None }
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { None }
}

impl Character for Human {
    fn as_human(&amp;self) -&gt; Option&lt;&amp;Human&gt; { Some(&amp;self) }
}

impl Character for Droid {
    fn as_droid(&amp;self) -&gt; Option&lt;&amp;Droid&gt; { Some(&amp;self) }
}

juniper::graphql_union!(&lt;'a&gt; &amp;'a Character: () as &quot;Character&quot; where Scalar = &lt;S&gt; |&amp;self| { 
    instance_resolvers: |_| {
        // The left hand side indicates the concrete type T, the right hand
        // side should be an expression returning Option&lt;T&gt;
        &amp;Human =&gt; self.as_human(),
        &amp;Droid =&gt; self.as_droid(),
    }
});

# fn main() {}
</code></pre></pre>
<h3><a class="header" href="#using-an-extra-database-lookup-1" id="using-an-extra-database-lookup-1">Using an extra database lookup</a></h3>
<p>FIXME: This example does not compile at the moment</p>
<pre><pre class="playpen"><code class="language-rust"># use std::collections::HashMap;
#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}

impl juniper::Context for Database {}

trait Character {
    fn id(&amp;self) -&gt; &amp;str;
}

impl Character for Human {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

impl Character for Droid {
    fn id(&amp;self) -&gt; &amp;str { self.id.as_str() }
}

juniper::graphql_union!(&lt;'a&gt; &amp;'a Character: Database as &quot;Character&quot; where Scalar = &lt;S&gt; |&amp;self| {
    instance_resolvers: |&amp;context| {
        &amp;Human =&gt; context.humans.get(self.id()),
        &amp;Droid =&gt; context.droids.get(self.id()),
    }
});

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#placeholder-objects-1" id="placeholder-objects-1">Placeholder objects</a></h2>
<pre><pre class="playpen"><code class="language-rust"># use std::collections::HashMap;
#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
#[graphql(Context = Database)]
struct Droid {
    id: String,
    primary_function: String,
}

struct Database {
    humans: HashMap&lt;String, Human&gt;,
    droids: HashMap&lt;String, Droid&gt;,
}

impl juniper::Context for Database {}

struct Character {
    id: String,
}

juniper::graphql_union!(Character: Database where Scalar = &lt;S&gt; |&amp;self| {
    instance_resolvers: |&amp;context| {
        &amp;Human =&gt; context.humans.get(&amp;self.id),
        &amp;Droid =&gt; context.droids.get(&amp;self.id),
    }
});

# fn main() {}
</code></pre></pre>
<h2><a class="header" href="#enums-2" id="enums-2">Enums</a></h2>
<pre><pre class="playpen"><code class="language-rust">#[derive(juniper::GraphQLObject)]
struct Human {
    id: String,
    home_planet: String,
}

#[derive(juniper::GraphQLObject)]
struct Droid {
    id: String,
    primary_function: String,
}

# #[allow(dead_code)]
enum Character {
    Human(Human),
    Droid(Droid),
}

juniper::graphql_union!(Character: () where Scalar = &lt;S&gt; |&amp;self| {
    instance_resolvers: |_| {
        &amp;Human =&gt; match *self { Character::Human(ref h) =&gt; Some(h), _ =&gt; None },
        &amp;Droid =&gt; match *self { Character::Droid(ref d) =&gt; Some(d), _ =&gt; None },
    }
});

# fn main() {}
</code></pre></pre>
<h1><a class="header" href="#schemas" id="schemas">Schemas</a></h1>
<p>A schema consists of two types: a query object and a mutation object (Juniper
does not support subscriptions yet). These two define the root query fields
and mutations of the schema, respectively.</p>
<p>Both query and mutation objects are regular GraphQL objects, defined like any
other object in Juniper. The mutation object, however, is optional since schemas
can be read-only.</p>
<p>In Juniper, the <code>RootNode</code> type represents a schema. You usually don’t have to
create this object yourself: see the framework integrations for <a href="schema/../servers/iron.html">Iron</a>
and <a href="schema/../servers/rocket.html">Rocket</a> how schemas are created together with the handlers
themselves.</p>
<p>When the schema is first created, Juniper will traverse the entire object graph
and register all types it can find. This means that if you define a GraphQL
object somewhere but never references it, it will not be exposed in a schema.</p>
<h2><a class="header" href="#the-query-root" id="the-query-root">The query root</a></h2>
<p>The query root is just a GraphQL object. You define it like any other GraphQL
object in Juniper, most commonly using the <code>object</code> proc macro:</p>
<pre><pre class="playpen"><code class="language-rust"># use juniper::FieldResult;
# #[derive(juniper::GraphQLObject)] struct User { name: String }
struct Root;

#[juniper::object]
impl Root {
    fn userWithUsername(username: String) -&gt; FieldResult&lt;Option&lt;User&gt;&gt; {
        // Look up user in database...
# unimplemented!()
    }
}

# fn main() { }
</code></pre></pre>
<h2><a class="header" href="#mutations" id="mutations">Mutations</a></h2>
<p>Mutations are <em>also</em> just GraphQL objects. Each mutation is a single field that
usually performs some mutating side-effect, such as updating a database.</p>
<pre><pre class="playpen"><code class="language-rust"># use juniper::FieldResult;
# #[derive(juniper::GraphQLObject)] struct User { name: String }
struct Mutations;

#[juniper::object]
impl Mutations {
    fn signUpUser(name: String, email: String) -&gt; FieldResult&lt;User&gt; {
        // Validate inputs and save user in database...
# unimplemented!()
    }
}

# fn main() { }
</code></pre></pre>
<h1><a class="header" href="#adding-a-server" id="adding-a-server">Adding A Server</a></h1>
<p>To allow using Juniper with the HTTP server of your choice,
it does <strong>not</strong> come with a built in HTTP server.</p>
<p>To actually get a server up and running, there are multiple official and 
third-party integration crates that will get you there.</p>
<ul>
<li><a href="servers/official.html">Official Server Integrations</a>
<ul>
<li><a href="servers/hyper.html">Hyper</a></li>
<li><a href="servers/warp.html">Warp</a></li>
<li><a href="servers/rocket.html">Rocket</a></li>
<li><a href="servers/iron.html">Iron</a></li>
<li><a href="servers/hyper.html">Hyper</a></li>
</ul>
</li>
<li><a href="servers/third-party.html">Third Party Integrations</a>
<ul>
<li><a href="https://github.com/actix/examples/tree/master/juniper">Actix-Web</a></li>
<li><a href="https://github.com/finchers-rs/finchers-juniper">Finchers</a></li>
<li><a href="https://github.com/tsukuyomi-rs/tsukuyomi/tree/master/examples/juniper">Tsukuyomi</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#official-server-integrations" id="official-server-integrations">Official Server Integrations</a></h1>
<p>Juniper provides official integration crates for several popular Rust server
libraries.</p>
<ul>
<li><a href="servers/hyper.html">Hyper</a></li>
<li><a href="servers/warp.html">Warp</a></li>
<li><a href="servers/rocket.html">Rocket</a></li>
<li><a href="servers/iron.html">Iron</a></li>
</ul>
<h1><a class="header" href="#integrating-with-warp" id="integrating-with-warp">Integrating with Warp</a></h1>
<p><a href="https://crates.io/crates/warp">Warp</a> is a super-easy, composable, web server framework for warp speeds.
The fundamental building block of warp is the Filter: they can be combined and composed to express rich requirements on requests. Warp is built on <a href="https://hyper.rs/">Hyper</a> and works on
Rust’s stable channel.</p>
<p>Juniper’s Warp integration is contained in the <a href="https://github.com/graphql-rust/juniper/tree/master/juniper_warp"><code>juniper_warp</code></a> crate:</p>
<p>!FILENAME Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.10&quot;
juniper_warp = &quot;0.1.0&quot;
</code></pre>
<p>Included in the source is a <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_warp/examples/warp_server.rs">small example</a> which sets up a basic GraphQL and <a href="https://github.com/graphql/graphiql">GraphiQL</a> handler.</p>
<h1><a class="header" href="#integrating-with-rocket" id="integrating-with-rocket">Integrating with Rocket</a></h1>
<p><a href="https://rocket.rs/">Rocket</a> is a web framework for Rust that makes it simple to write fast web applications without sacrificing flexibility or type safety. All with minimal code. Rocket
does not work on Rust’s stable channel and instead requires the nightly
channel.</p>
<p>Juniper’s Rocket integration is contained in the <a href="https://github.com/graphql-rust/juniper/tree/master/juniper_rocket"><code>juniper_rocket</code></a> crate:</p>
<p>!FILENAME Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.10&quot;
juniper_rocket = &quot;0.2.0&quot;
</code></pre>
<p>Included in the source is a <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_rocket/examples/rocket_server.rs">small example</a> which sets up a basic GraphQL and <a href="https://github.com/graphql/graphiql">GraphiQL</a> handler.</p>
<h1><a class="header" href="#integrating-with-iron" id="integrating-with-iron">Integrating with Iron</a></h1>
<p><a href="http://ironframework.io">Iron</a> is a library that’s been around for a while in the Rust sphere but lately
hasn’t seen much of development. Nevertheless, it’s still a solid library with a
familiar request/response/middleware architecture that works on Rust’s stable
channel.</p>
<p>Juniper’s Iron integration is contained in the <code>juniper_iron</code> crate:</p>
<p>!FILENAME Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.10&quot;
juniper_iron = &quot;0.2.0&quot;
</code></pre>
<p>Included in the source is a <a href="https://github.com/graphql-rust/juniper_iron/blob/master/examples/iron_server.rs">small
example</a>
which sets up a basic GraphQL and <a href="https://github.com/graphql/graphiql">GraphiQL</a> handler.</p>
<h2><a class="header" href="#basic-integration" id="basic-integration">Basic integration</a></h2>
<p>Let’s start with a minimal schema and just get a GraphQL endpoint up and
running. We use <a href="https://github.com/iron/mount">mount</a> to attach the GraphQL handler at <code>/graphql</code>.</p>
<p>The <code>context_factory</code> function will be executed on every request and can be used
to set up database connections, read session token information from cookies, and
set up other global data that the schema might require.</p>
<p>In this example, we won’t use any global data so we just return an empty value.</p>
<pre><code class="language-rust ignore">extern crate juniper;
extern crate juniper_iron;
extern crate iron;
extern crate mount;

use mount::Mount;
use iron::prelude::*;
use juniper::EmptyMutation;
use juniper_iron::GraphQLHandler;

fn context_factory(_: &amp;mut Request) -&gt; IronResult&lt;()&gt; {
    Ok(())
}

struct Root;

#[juniper::object]
impl Root {
    fn foo() -&gt; String {
        &quot;Bar&quot;.to_owned()
    }
}

# #[allow(unreachable_code, unused_variables)]
fn main() {
    let mut mount = Mount::new();

    let graphql_endpoint = GraphQLHandler::new(
        context_factory,
        Root,
        EmptyMutation::&lt;()&gt;::new(),
    );

    mount.mount(&quot;/graphql&quot;, graphql_endpoint);

    let chain = Chain::new(mount);

#   return;
    Iron::new(chain).http(&quot;0.0.0.0:8080&quot;).unwrap();
}
</code></pre>
<h2><a class="header" href="#accessing-data-from-the-request" id="accessing-data-from-the-request">Accessing data from the request</a></h2>
<p>If you want to access e.g. the source IP address of the request from a field
resolver, you need to pass this data using Juniper’s <a href="servers/../types/objects/using_contexts.html">context feature</a>.</p>
<pre><code class="language-rust ignore"># extern crate juniper;
# extern crate juniper_iron;
# extern crate iron;
# use iron::prelude::*;
use std::net::SocketAddr;

struct Context {
    remote_addr: SocketAddr,
}

impl juniper::Context for Context {}

fn context_factory(req: &amp;mut Request) -&gt; IronResult&lt;Context&gt; {
    Ok(Context {
        remote_addr: req.remote_addr
    })
}

struct Root;

#[juniper::object(
    Context = Context,
)]
impl Root {
    field my_addr(context: &amp;Context) -&gt; String {
        format!(&quot;Hello, you're coming from {}&quot;, context.remote_addr)
    }
}

# fn main() {
#     let _graphql_endpoint = juniper_iron::GraphQLHandler::new(
#         context_factory,
#         Root,
#         juniper::EmptyMutation::&lt;Context&gt;::new(),
#     );
# }
</code></pre>
<h1><a class="header" href="#integrating-with-hyper" id="integrating-with-hyper">Integrating with Hyper</a></h1>
<p><a href="https://hyper.rs/">Hyper</a> is a is a fast HTTP implementation that many other Rust web frameworks
leverage. It offers asynchronous I/O via the tokio runtime and works on
Rust’s stable channel.</p>
<p>Hyper is not a higher-level web framework and accordingly
does not include ergonomic features such as simple endpoint routing,
baked-in HTTP responses, or reusable middleware. For GraphQL, those aren’t
large downsides as all POSTs and GETs usually go through a single endpoint with
a few clearly-defined response payloads.</p>
<p>Juniper’s Hyper integration is contained in the <a href="https://github.com/graphql-rust/juniper/tree/master/juniper_hyper"><code>juniper_hyper</code></a> crate:</p>
<p>!FILENAME Cargo.toml</p>
<pre><code class="language-toml">[dependencies]
juniper = &quot;0.10&quot;
juniper_hyper = &quot;0.1.0&quot;
</code></pre>
<p>Included in the source is a <a href="https://github.com/graphql-rust/juniper/blob/master/juniper_hyper/examples/hyper_server.rs">small example</a> which sets up a basic GraphQL and <a href="https://github.com/graphql/graphiql">GraphiQL</a> handler.</p>
<h1><a class="header" href="#third-party-integrations" id="third-party-integrations">Third-Party Integrations</a></h1>
<p>There are several examples or third party integration crates that are not
officially maintained by Juniper developers.</p>
<ul>
<li><a href="https://github.com/actix/examples/tree/master/juniper">Actix-Web</a></li>
<li><a href="https://github.com/finchers-rs/finchers-juniper">Finchers</a></li>
<li><a href="https://github.com/tsukuyomi-rs/tsukuyomi/tree/master/examples/juniper">Tsukuyomi</a></li>
</ul>
<h1><a class="header" href="#advanced-topics" id="advanced-topics">Advanced Topics</a></h1>
<p>The chapters below cover some more advanced scenarios.</p>
<ul>
<li><a href="advanced/introspection.html">Introspection</a></li>
<li><a href="advanced/non_struct_objects.html">Non-struct objects</a></li>
<li><a href="advanced/objects_and_generics.html">Objects and generics</a></li>
<li><a href="advanced/multiple_ops_per_request.html">Multiple operations per request</a></li>
</ul>
<h1><a class="header" href="#introspection" id="introspection">Introspection</a></h1>
<p>GraphQL defines a special built-in top-level field called <code>__schema</code>. Querying
for this field allows one to <a href="https://graphql.org/learn/introspection/">introspect the schema</a>
at runtime to see what queries and mutations the GraphQL server supports.</p>
<p>Because introspection queries are just regular GraphQL queries, Juniper supports
them natively. For example, to get all the names of the types supported one
could execute the following query against Juniper:</p>
<pre><code class="language-graphql">{
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<h2><a class="header" href="#schema-introspection-output-as-json" id="schema-introspection-output-as-json">Schema introspection output as JSON</a></h2>
<p>Many client libraries and tools in the GraphQL ecosystem require a complete
representation of the server schema. Often this representation is in JSON and
referred to as <code>schema.json</code>. A complete representation of the schema can be
produced by issuing a specially crafted introspection query.</p>
<p>Juniper provides a convenience function to introspect the entire schema. The
result can then be converted to JSON for use with tools and libraries such as
<a href="https://github.com/graphql-rust/graphql-client">graphql-client</a>:</p>
<pre><pre class="playpen"><code class="language-rust">use juniper::{EmptyMutation, FieldResult, IntrospectionFormat};

// Define our schema.

#[derive(juniper::GraphQLObject)]
struct Example {
  id: String,
}

struct Context;
impl juniper::Context for Context {}

struct Query;

#[juniper::object(
  Context = Context,
)]
impl Query {
   fn example(id: String) -&gt; FieldResult&lt;Example&gt; {
       unimplemented!()
   }
}

type Schema = juniper::RootNode&lt;'static, Query, EmptyMutation&lt;Context&gt;&gt;;

fn main() {
    // Create a context object.
    let ctx = Context{};

    // Run the built-in introspection query.
    let (res, _errors) = juniper::introspect(
        &amp;Schema::new(Query, EmptyMutation::new()),
        &amp;ctx,
        IntrospectionFormat::default(),
    ).unwrap();

    // Convert introspection result to json.
    let json_result = serde_json::to_string_pretty(&amp;res);
    assert!(json_result.is_ok());
}
</code></pre></pre>
<h1><a class="header" href="#non-struct-objects" id="non-struct-objects">Non-struct objects</a></h1>
<p>Up until now, we’ve only looked at mapping structs to GraphQL objects. However,
any Rust type can be mapped into a GraphQL object. In this chapter, we’ll look
at enums, but traits will work too - they don’t <em>have</em> to be mapped into GraphQL
interfaces.</p>
<p>Using <code>Result</code>-like enums can be a useful way of reporting e.g. validation
errors from a mutation:</p>
<pre><pre class="playpen"><code class="language-rust"># #[derive(juniper::GraphQLObject)] struct User { name: String }

#[derive(juniper::GraphQLObject)]
struct ValidationError {
    field: String,
    message: String,
}

# #[allow(dead_code)]
enum SignUpResult {
    Ok(User),
    Error(Vec&lt;ValidationError&gt;),
}

#[juniper::object]
impl SignUpResult {
    fn user(&amp;self) -&gt; Option&lt;&amp;User&gt; {
        match *self {
            SignUpResult::Ok(ref user) =&gt; Some(user),
            SignUpResult::Error(_) =&gt; None,
        }
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        match *self {
            SignUpResult::Ok(_) =&gt; None,
            SignUpResult::Error(ref errors) =&gt; Some(errors)
        }
    }
}

# fn main() {}
</code></pre></pre>
<p>Here, we use an enum to decide whether a user’s input data was valid or not, and
it could be used as the result of e.g. a sign up mutation.</p>
<p>While this is an example of how you could use something other than a struct to
represent a GraphQL object, it’s also an example on how you could implement
error handling for “expected” errors - errors like validation errors. There are
no hard rules on how to represent errors in GraphQL, but there are
<a href="https://github.com/facebook/graphql/issues/117#issuecomment-170180628">some</a>
<a href="https://github.com/graphql/graphql-js/issues/560#issuecomment-259508214">comments</a>
from one of the authors of GraphQL on how they intended “hard” field errors to
be used, and how to model expected errors.</p>
<h1><a class="header" href="#objects-and-generics" id="objects-and-generics">Objects and generics</a></h1>
<p>Yet another point where GraphQL and Rust differs is in how generics work. In
Rust, almost any type could be generic - that is, take type parameters. In
GraphQL, there are only two generic types: lists and non-nullables.</p>
<p>This poses a restriction on what you can expose in GraphQL from Rust: no generic
structs can be exposed - all type parameters must be bound. For example, you can
not make e.g. <code>Result&lt;T, E&gt;</code> into a GraphQL type, but you <em>can</em> make e.g.
<code>Result&lt;User, String&gt;</code> into a GraphQL type.</p>
<p>Let’s make a slightly more compact but generic implementation of <a href="advanced/non_struct_objects.html">the last
chapter</a>:</p>
<pre><pre class="playpen"><code class="language-rust"># #[derive(juniper::GraphQLObject)] struct User { name: String }
# #[derive(juniper::GraphQLObject)] struct ForumPost { title: String }

#[derive(juniper::GraphQLObject)]
struct ValidationError {
    field: String,
    message: String,
}

# #[allow(dead_code)]
struct MutationResult&lt;T&gt;(Result&lt;T, Vec&lt;ValidationError&gt;&gt;);

#[juniper::object(
    name = &quot;UserResult&quot;,
)]
impl MutationResult&lt;User&gt; {
    fn user(&amp;self) -&gt; Option&lt;&amp;User&gt; {
        self.0.as_ref().ok()
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        self.0.as_ref().err()
    }
}

#[juniper::object(
    name = &quot;ForumPostResult&quot;,
)]
impl MutationResult&lt;ForumPost&gt; {
    fn forum_post(&amp;self) -&gt; Option&lt;&amp;ForumPost&gt; {
        self.0.as_ref().ok()
    }

    fn error(&amp;self) -&gt; Option&lt;&amp;Vec&lt;ValidationError&gt;&gt; {
        self.0.as_ref().err()
    }
}

# fn main() {}
</code></pre></pre>
<p>Here, we’ve made a wrapper around <code>Result</code> and exposed some concrete
instantiations of <code>Result&lt;T, E&gt;</code> as distinct GraphQL objects. The reason we
needed the wrapper is of Rust’s rules for when you can derive a trait - in this
case, both <code>Result</code> and Juniper’s internal GraphQL trait are from third-party
sources.</p>
<p>Because we’re using generics, we also need to specify a name for our
instantiated types. Even if Juniper <em>could</em> figure out the name,
<code>MutationResult&lt;User&gt;</code> wouldn’t be a valid GraphQL type name.</p>
<h1><a class="header" href="#multiple-operations-per-request" id="multiple-operations-per-request">Multiple operations per request</a></h1>
<p>The GraphQL standard generally assumes there will be one server request for each client operation you want to perform (such as a query or mutation). This is conceptually simple but has the potential to be inefficent.</p>
<p>Some client libraries such as <a href="https://www.apollographql.com/docs/link/links/batch-http.html">apollo-link-batch-http</a> have added the ability to batch operations in a single HTTP request to save network round-trips and potentially increase performance. There are some <a href="https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b">tradeoffs</a> that should be considered before batching requests.</p>
<p>Juniper’s server integration crates support multiple operations in a single HTTP request using JSON arrays. This makes them compatible with client libraries that support batch operations without any special configuration.</p>
<p>Server integration crates maintained by others are <strong>not required</strong> to support batch requests. Batch requests aren’t part of the official GraphQL specification.</p>
<p>Assuming an integration supports batch requests, for the following GraphQL query:</p>
<pre><code class="language-graphql">{
  hero {
    name
  }
}
</code></pre>
<p>The json data to POST to the server for an individual request would be:</p>
<pre><code class="language-json">{
  &quot;query&quot;: &quot;{hero{name}}&quot;
}
</code></pre>
<p>And the response would be of the form:</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;hero&quot;: {
      &quot;name&quot;: &quot;R2-D2&quot;
    }
  }
}
</code></pre>
<p>If you wanted to run the same query twice in a single HTTP request, the batched json data to POST to the server would be:</p>
<pre><code class="language-json">[
  {
    &quot;query&quot;: &quot;{hero{name}}&quot;
  },
  {
    &quot;query&quot;: &quot;{hero{name}}&quot;
  }
]
</code></pre>
<p>And the response would be of the form:</p>
<pre><code class="language-json">[
  {
    &quot;data&quot;: {
      &quot;hero&quot;: {
        &quot;name&quot;: &quot;R2-D2&quot;
      }
    }
  },
  {
    &quot;data&quot;: {
      &quot;hero&quot;: {
        &quot;name&quot;: &quot;R2-D2&quot;
      }
    }
  }
]
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
